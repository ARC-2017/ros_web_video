
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>three.js - kinect</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color: #ffffff;

				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				font-weight: bold;

				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #0040ff;

			}
		</style>
	</head>
	<body>

		<script src="../build/three.min.js"></script>

		<script src='js/libs/DAT.GUI.min.js'></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script id="vs" type="x-shader/x-vertex">

			uniform sampler2D map;

			uniform float width;
			uniform float height;
			uniform float nearClipping, farClipping;

			uniform float pointSize;
			uniform float zOffset;

                        varying vec2 vUvP;
                        varying vec2 colorP;

                        varying float vari;
                        varying float maskVal;

			const float XtoZ = 1.11146; // tan( 1.0144686 / 2.0 ) * 2.0;
			const float YtoZ = 0.83359; // tan( 0.7898090 / 2.0 ) * 2.0;

                        float sampleDepth(vec2 pos)
			{
			   float depth;
			   
			   vec2 vUv = vec2( pos.x / (width*2.0), pos.y / (height*2.0)+0.5 );
			   vec2 vUv2 = vec2( pos.x / (width*2.0)+0.5, pos.y / (height*2.0)+0.5 );

			   vec4 depthColor = texture2D( map, vUv );

			   depth = ( depthColor.r + depthColor.g + depthColor.b ) / 3.0 ;

			   if (depth>0.99)
			   {
				vec4 depthColor2 = texture2D( map, vUv2 );
				float depth2 = ( depthColor2.r + depthColor2.g + depthColor2.b ) / 3.0 ;
				depth = 1.0+depth2;
			   }

			   return depth;
			}

                        float median(float a, float b, float c)
			{
			   float r=a;
			   
			   if ( (a<b) && (b<c) )
			   {
			     r = b;
			   }
			   if ( (a<c) && (c<b) )
			   {
			     r = c;
			   }
			   return r;
			}

                        float variance(float d1, float d2, float d3, float d4, float d5, float d6, float d7, float d8, float d9)
			{
                           float mean = (d1 + d2 + d3 + d4 + d5 + d6 + d7 + d8 + d9) / 9.0;
                           float t1 = (d1-mean);
                           float t2 = (d2-mean);
                           float t3 = (d3-mean);
                           float t4 = (d4-mean);
                           float t5 = (d5-mean);
                           float t6 = (d6-mean);
                           float t7 = (d7-mean);
                           float t8 = (d8-mean);
                           float t9 = (d9-mean);
                           float r = (t1*t1+t2*t2+t3*t3+t4*t4+t5*t5+t6*t6+t7*t7+t8*t8+t9*t9)/9.0;
			   return r;
			}

                        vec2 decodeDepth(vec2 pos)
			{
			   vec2 ret;	   

                          float depth1 = sampleDepth(vec2(position.x-1.0, position.y-1.0));
		  	  float depth2 = sampleDepth(vec2(position.x, position.y-1.0));
	  		  float depth3 = sampleDepth(vec2(position.x+1.0, position.y-1.0));
			  float depth4 = sampleDepth(vec2(position.x-1.0, position.y));
		          float depth5 = sampleDepth(vec2(position.x, position.y));
			  float depth6 = sampleDepth(vec2(position.x+1.0, position.y));
			  float depth7 = sampleDepth(vec2(position.x-1.0, position.y+1.0));
			  float depth8 = sampleDepth(vec2(position.x, position.y+1.0));
			  float depth9 = sampleDepth(vec2(position.x+1.0, position.y+1.0));

                          float median1 = median(depth1, depth2, depth3);
                          float median2 = median(depth4, depth5, depth6);
                          float median3 = median(depth7, depth8, depth9);

                          ret.x = median(median1, median2, median3);
                          ret.y = variance(depth1, depth2, depth3, depth4, depth5, depth6, depth7, depth8, depth9);
                          
                          return ret;

			}



			void main() {

				vUvP = vec2( position.x / (width*2.0), position.y / (height*2.0)+0.5 );
			        colorP = vec2( position.x / (width*2.0)+0.5 , position.y / (height*2.0)  );
                                
				vec4 pos = vec4(0.0,0.0,0.0,0.0);
                                vari = 0.0;
				
                                if ( (vUvP.x<0.0)|| (vUvP.x>0.5) || (vUvP.y<0.5) || (vUvP.y>0.0))
				{

                                         vec2 smp = decodeDepth(vec2(position.x, position.y));
                                         float depth = smp.x;
                                         vari = smp.y;

					if (depth>0.02)
					{
					 float z = ( 1.0 - depth * (-0.5) ) * (farClipping - nearClipping) + nearClipping;

					     pos = vec4(
					 	( position.x / width - 0.5 ) * z * XtoZ,
					 	( position.y / height - 0.5 ) * z * YtoZ,
					 	- z + zOffset,
					 	1.0);


                                         vec2 maskP = vec2( position.x / (width*2.0), position.y / (height*2.0)  );
			                 vec4 maskColor = texture2D( map, maskP );
					 maskVal = ( maskColor.r + maskColor.g + maskColor.b ) / 3.0 ;
					} else
					{
					maskVal = 1.0;	
					}


				}

				gl_PointSize = pointSize;
				gl_Position = projectionMatrix * modelViewMatrix * pos;

			}

		</script>

		<script id="fs" type="x-shader/x-fragment">

			uniform sampler2D map;
                        uniform float varianceFilter;
                        uniform float colorFader;

                        varying vec2 vUvP;
                        varying vec2 colorP;

                        varying float vari;
                        varying float maskVal;
                       

			void main() {

                                vec4 color;
                                
                                float varThres = 0.001-(varianceFilter/1000.0)*0.001; 
                                if ( (vari>varThres) || (maskVal>0.5) ||(vUvP.x<0.0)|| (vUvP.x>0.5) || (vUvP.y<0.5) || (vUvP.y>1.0))
				{
				        color.r = 0.0;
					color.g = 0.0;
					color.b = 0.0;
				} else 
                                {
                                        color = texture2D( map, colorP );

			                float fader = colorFader /100.0;

			                color.r = color.r * (1.0-fader)+ fader;                               
			                color.g = color.g * (1.0-fader)+ fader;                               
			                color.b = color.b * (1.0-fader)+ fader;                               

                                }

				gl_FragColor = vec4( color.r, color.g, color.b, smoothstep( 8000.0, -8000.0, gl_FragCoord.z / gl_FragCoord.w ) );

			}

		</script>

		<script>

			var container;

			var scene, camera, light, renderer;
			var geometry, cube, mesh, material;
			var mouse, center;
			var stats;

			var video, texture;

			if ( Detector.webgl ) {

				init();
				animate();

			} else {

				document.body.appendChild( Detector.getWebGLErrorMessage() );

			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				var info = document.createElement( 'div' );
				info.id = 'info';
				info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> - kinect';
				document.body.appendChild( info );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				// container.appendChild( stats.domElement );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 0, 0, 400 );

				scene = new THREE.Scene();
				center = new THREE.Vector3();
				center.z = - 1000;

				video = document.createElement( 'video' );
				video.addEventListener( 'loadedmetadata', function ( event ) {

					texture = new THREE.Texture( video ); 
                                        

					var width = 1024, height = 1024;
					var nearClipping = 850/*850*/, farClipping = 4000/*4000*/;
					var colorFader = 0;
					var varianceFilter = 500;

					geometry = new THREE.Geometry();

					for ( var i = 0, l = width * height; i < l; i ++ ) {

						var vertex = new THREE.Vector3();
						vertex.x = ( i % width );
						vertex.y = Math.floor( i / width );

						geometry.vertices.push( vertex );

					}

					material = new THREE.ShaderMaterial( {

						uniforms: {

							"map": { type: "t", value: texture },
							"width": { type: "f", value: width },
							"height": { type: "f", value: height },
							"nearClipping": { type: "f", value: nearClipping },
							"farClipping": { type: "f", value: farClipping },

							"pointSize": { type: "f", value: 2 },
							"zOffset": { type: "f", value: 1000 },
                                                        "colorFader": { type: "f", value: colorFader },
							"varianceFilter": { type: "f", value: varianceFilter }

						},
						vertexShader: document.getElementById( 'vs' ).textContent,
						fragmentShader: document.getElementById( 'fs' ).textContent,
						depthWrite: false

					} );

					mesh = new THREE.ParticleSystem( geometry, material );
					mesh.position.x = 0;
					mesh.position.y = 0;
					scene.add( mesh );

					setInterval( function () {

						if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

							texture.needsUpdate = true;

						}

					}, 1000 / 30 );


					var gui = new DAT.GUI();
					gui.add( material.uniforms.nearClipping, 'value' ).name( 'nearClipping' ).min( 1 ).max( 10000 ).step( 1.0 );
					gui.add( material.uniforms.farClipping, 'value' ).name( 'farClipping' ).min( 1 ).max( 10000 ).step( 1.0 );
					gui.add( material.uniforms.pointSize, 'value' ).name( 'pointSize' ).min( 1 ).max( 10 ).step( 1.0 );
					gui.add( material.uniforms.zOffset, 'value' ).name( 'zOffset' ).min( 0 ).max( 4000 ).step( 1.0 );
					gui.add( material.uniforms.colorFader, 'value' ).name( 'colorFader' ).min( 0 ).max( 100 ).step( 1.0 );
                                        gui.add( material.uniforms.varianceFilter, 'value' ).name( 'varianceFilter' ).min( 0 ).max( 1000 ).step( 1.0 );
					gui.close();


				}, false );
				video.loop = true;
				video.src = 'textures/depth_color.webm';//kinect-cp.webm';
				video.play();


				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				mouse = new THREE.Vector3( 0, 0, 1 );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				mouse.x = ( event.clientX - window.innerWidth / 2 ) * 8;
				mouse.y = ( event.clientY - window.innerHeight / 2 ) * 8;

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				camera.position.x += ( mouse.x - camera.position.x ) * 0.05;
				camera.position.y += ( - mouse.y - camera.position.y ) * 0.05;
				camera.lookAt( center );

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
